DONE -->  add new shader Pair for 3d
DONE -->  Get and use/learn the best m4 library
DONE -->  Create Triangle3D, Derive Quad3D from Triangle 3D
DONE -->  add folder named ShaderFactory // Building Base
	- config.js
		- list of { program ID, shaderIds, attribs, uniforms, (texture) }
	- constants.js
		- Program ID Enum
	- GLInitializer.js
		- Takes list of program Ids to initialize with
		- shaderPrograms[id] = { ...programCongig }
		- initLocations
	- Canvas.js
		- constructor(programIdList)
		
DONE -->  Create first 3d scene with camera
DONE -->  enable depth test
DONE -->  face culling
DONE -->  SceneConfig class - constructor(viewport, camera)
DONE -->  create instances sceneConfig1, sceneConfig2, ... with different camera/viewport
DONE -->  render(sceneConfig) => { wo.render(sceneConfig) => setCamera()}
DONE -->  Change Transform matrix - add class
DONE -->  ModelTransformMatrix for objects
DONE -->  Matrix4:getInverseTransposeMatrix()
DONE -->  Matrix4:applyInverseTransposeMatrix(vec3)
DONE -->  Add normals based on a flag, in the buffers
DONE -->  Add new shader program for directional light
DONE -->  Add new renderConfig file named renderConfigLight
DONE -->  set UniformGetter for additional uniforms
DONE -->  fix the Matrix4 multiply order
DONE -->  create Box3D
DONE -->  Add ambient term in the shader
DONE -->  define material properties for WorldObject as defineProperty
DONE -->  make coefficients as zero by default
	k_ambient
	k_diffuse
	k_specular
	shininess
	emissive_color

DONE -->  Fix issue while thetaPhi cam is on top objects get too closer

DONE -->  Rename Cam to Camera (Camera Abstraction)

DONE -->  Sun setupScene(ObjRenderer) set color and direction getters 
DONE -->  Light setupScene(ObjRenderer) set light position and color getters 
DONE -->  Shader: WorldViewprojection => ViewProjection * World
DONE -->  Camera setupScene, set ViewProjection matrix getter


----------06/06/2017-------------------------------
DONE ---> git commit and push current status
DONE ---> double click for fullscreen
DONE ---> Fix loading not shown while loading issue
DONE ---> Add SceneBuilder, Add WorldObjectStore, restructure to render
DONE ---> render based on renderOnce in the main scene builder
DONE ---> Loop and render based on the flag renderOnce

DONE ---> Each WO has rebuildProperties flag (default with true)
DONE ---> If we update any property of this object we set rebuildProperties=true
DONE ---> Change getProperty workflow based on this.
DONE ---> Post render make this flag false

DONE ---> WO derives from Node class
DONE ---> Node: Introduce children [], setChildren([])
DONE ---> setParentProperties( properties ) { 
	this.parentProperties = { ...this.parentProperties,  ...properties } //override existing
	this.rebuildProperties = true;
}
DONE ---> Move all property methods into Node
DONE ---> Introduce world_matrix property (init with Identity matrix)
DONE ---> world_matrix propertyGetter => compute parentProperties.world_matrix * model_matrix
DONE ---> world_matrix propertyGetter => pass down to children setParentProperties( { world_matrix });
DONE ---> Rewrite objRenderer.setUniformGetter(SHADER_VARS.u_world..) to take world_matrix

DONE ---> Bug: light postion change is not reflected in the scene
DONE ---> Test newly implemented Scene Graph

DONE ---> Fix: canvas resolution on mobile browser (chrome) is very less
DONE ---> considered window.devicePixelRatio to find high def width
DONE ---> Fix: why rotation demo is running slow + jerky
DONE ---> Made use of requestAnimationFrame
DONE ---> Optymized the render calls based on timestamp updates
DONE ---> lock the device orientation while fullscreen
DONE ---> changes m4.vectorMultiply => transformVector(v, m)

DONE ---> All scene setters should derive from the class : SceneSetter
DONE ---> SceneSetter class
	- SceneSetterType: camera, light source etc from NodeType List
	- isActive property (implies is ON OFF)
	- must have a setSceneMethod invoke based on isActive value
===========================================

Every WO has:
	- a unique Id
	- a type

Remove/Reuse lib/SceneConfig.js	

Define Scene class
	- NodeList for rendering
	- Scene setters
		- Check current workflow
		- Iterate and produce a list of Scene setters from NodeList
		- Each scene setter has isActive flag
		- currentActive camera Id
		- return active sceneSetters
	- Viewport (W.R.T Canvas coordinates and NOT normalized)
	- render method
	
Define LayoutGenerator
	- inputs (type: grid, rows, columns) - for now
	- detailed input for getting custom layouts - can be done later
	- returns layout {"i-j": viewport }

Define CanvasView:
	- AssignmentList { scene, viewport }
	- render method

Node.generateId() this.Id = [IdProvidedByUser]_[timestamp]
Node.createObjects() { this.generateId() }

Ctrl+Shift+A => display all keyboard/user input options

Do we really need initList ? can we reuse the values in propertyList ?

Factory creation of Geometry Objects based on NodeType

differentiate sceneConfig and scene
One view can have list of scenes
scene is created out of a scene config

Introduce RobotView: only two invisible cameras and can return a splitScreenView for VR Headsets
Define properties like position, lookAtDirection, upVector etc

Differentiate Geometry Objects from WO
Geometry Objects: Two types
	Basic Objects: (, triangle, rectangle, sphere, box, cylinder, with customizible params),
	Composite Objects: Composition of different Basic Objects with higher input params
WO->addGeometryObject, can add multiple Geometry Objects

Geometry Object editing
setEditFlush(editFlush) {
	this.editFlush = editFlush;
}
editFlush is a method from ObjectRenderer which will edit the buffer for this Object

Define scene data, with all configurations and new Composite Objects
One scene data should ideally render a complete scene

No shape for camera
If we want a shape define a WO keep cam as child
Same holds for lights

RenderOptimizer: distant objects (from cam) are not visible
visibility off and in a closer distance alpha shoots up from 0 to 1

Bug: 2 cam type ThetaPhi wont work properly

Remove unnecessary forlders/files created


Text rendering from an invisible 2D canvas
At run time add a texture from this image

Coloring of Geometry based on a callback with all inputs
Color on vertex level



Fix the performance part generated by light house. Big gap for starting the app.

Quadratic attennation of light


Texts should be non-selectable

Make it more React-Redux project

Create two layouts switchable from one another

WorldObject has parent object default null
setParent()
new property "world_matrix"
property getter => parent_world_matrix * modelMatrix
woCache, setSceneConfig { woCache= null }, woCache.WorldMatrix
use this worldMatrix in uniformGetter

./WorldSceneStore/
	CameraWorldObject
	CameraThetaPhiWorldObject
	LightWorldObject
	DirLightWorldObject
	Sun
	CameraSolidObject
	CameraThetaPhiSolidObject
	LightSphereObject
	
./CustomScene001/
	index reades a sceneObject




Find out what is distorting the shapes in the scene


KeySubscriberConfig.js 
	[subscriberInfo]
Define KeyEventManager
	subscribeEvent(subscriberInfo);
	addEventListener('keydown' and 'keyup') notify subscribers

ceiling is a box


WO:addChild()
childList = []
WO:property "world_matrix"
traverse from top to bottom
world_matrix of child = world_matrix of parent * model_matrix

change SHADER_VARS.u_Lights_0_lightColor to SHADER_VARS.u_LightColor(0)

change sceneConfig object to SceneManager class instances
define setupScene => call setupScene of sceneSetters
prop "viewport" is not needed. use it as SceneManager.viewport

commit code into github account

canvas clearColor to skyColor = sunColor (for now)

Disc3D, innerRadius, OuterRadius
Cylinder3D, closeTop, closeBottom
Cone3D

sceneGraph each node has its matrix
traverse down and set world_matrix for each node
pass world_matrix to u_world

React based configure popup using a configurables object and set UI
callback whenever a change is triggered from user and return the config state

Every WO has a configurable list.
populate and get the popup for configuration

Wire view Rendering

Currently we have per quad color for objects. Change to per vertex color.

add normal for surface3D plane

colorGetter() default and overrides

remove unwanted imports from files
addVector, subt.. move to V3 and import V3

Optimize: Add pseudo rand Util method for colors

length and area based surface division to quad3ds
use sin(theta) to decide n at each height of sphere3d.
(this can save/improve efficiency for objects)


==+ LIGHT +===

float3 ambient = u_Ka * ambientLightColor;

float3 L = normalize(u_lightPosition - P);
float3 N = normalize(v_normal);
float3 diffuse = u_Kd * u_lightColor * diffuseLight;
float diffuseLight = max(dot(N, L), 0);


Ideally we should have provition to add normal per vertex for quad
Since we use only spherical objects keep normal as the vertex itself

Draw 2d lines for viewports- objectGroup2D

Create 3D line segment.
Draw y axis as a 3D line seg.

viewport 1 large and other small

colorBandWidth = 0 => single color, else multi
later make custom color generator callbacks




make appUtils default export	
color as input for RectSurface3D, Sphere3D
moving shaders into static text files and read from it
create path alias/shortcuts and use them appropriately
WorldScene0 - RoomObject 3 walls and a pillar in  cylinder shape
			- A ball on the floor
			- A box on the floor
			(Create a folder for each and create WorldObjects for each)


Figure out how to convert 16byte float color to 4byte(4 unsigned_byte)
	- Did not work out we need more time
	
	
Object Detection:
Entire problem will come down to solving ==> Given a line ( Point + Vector ) which side of the box it will hit next
OR short grid path from (i1, j1) to (i2, j2)
slope m = j2-j1 / i2-i1
line j-j1 / i-i1  =   m
iterate from i1 to i2 find j as ceil and floor both

M = inverse(projectionViewMatrix) p11=M*p1 p22=M*p2 first Object hitting this line